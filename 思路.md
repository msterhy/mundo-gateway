关于负载：
两种思路，一种是根据流量比大小。而另一种是直接哈希轮询。后者在计算方面速度更快。因此使用后者。

关于转发：
目前已经基于http实现。下一步用grpcgateway实现grpc转发。

todo：
同一个名字的service不能重复注册。
删掉prefix表
api表不能重复，三个字段都相同的话就是重复。
同一个service不能有重复的address

grpc转发思路：
直接grpc注册一张表，然后根据映射以及方法逻辑http转grpc
1.通过反射获取方法，然后根据方法名字进行转发，加缓存 √（暂时先用这个，但反射会有15%性能损耗。只需要微服务注册的时候发一个信号来提示更新，
其余只需要启动的时候注册一次）
2.proto放在仓库。动态更新：通过监听仓库变更（如 Git Webhook），自动触发网关重新加载 Proto 文件。
3.独立实现一个元数存储，存储所有的proto文件，然后进行proto的发布和订阅，网关动态编译proto文件。

缓存思路：
启动的时候就把数据库所有service加载到内存中全局gateway实例
然后在更新的时候直接拿读写锁并更新即可。

